--- net/ixgbe/ixgbe_main.c	2011-02-18 00:44:35.000000000 +0100
+++ net/ixgbe/ixgbe_main.c	2012-07-30 17:16:39.626237875 +0200
@@ -214,6 +214,22 @@
	{}
 };

+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+/*
+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
+ * be a reference on how to implement netmap support in a driver.
+ * Additional comments are in ixgbe_netmap_linux.h .
+ *
+ * The code is originally developed on FreeBSD and in the interest
+ * of maintainability we try to limit differences between the two systems.
+ *
+ * <ixgbe_netmap_linux.h> contains functions for netmap support
+ * that extend the standard driver.
+ * It also defines DEV_NETMAP so further conditional sections use
+ * that instead of CONFIG_NETMAP
+ */
+#include <ixgbe_netmap_linux.h>
+#endif

 /*
  * ixgbe_regdump - register printout routine
@@ -740,6 +756,16 @@
	unsigned int i, eop, count = 0;
	unsigned int total_bytes = 0, total_packets = 0;

+#ifdef DEV_NETMAP
+	/*
+	 * In netmap mode, all the work is done in the context
+	 * of the client thread. Interrupt handlers only wake up
+	 * clients, which may be sleeping on individual rings
+	 * or on a global resource for all rings.
+	 */
+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
+		return 1; /* seems to be ignored */
+#endif /* DEV_NETMAP */
	i = tx_ring->next_to_clean;
	eop = tx_ring->tx_buffer_info[i].next_to_watch;
	eop_desc = IXGBE_TX_DESC_ADV(tx_ring, eop);
@@ -1185,6 +1211,13 @@
	int ddp_bytes = 0;
 #endif /* IXGBE_FCOE */

+#ifdef DEV_NETMAP
+	/*
+	 * Same as the txeof routine: only wakeup clients on intr.
+	 */
+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
+		return;
+#endif /* DEV_NETMAP */
	i = rx_ring->next_to_clean;
	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
@@ -2519,6 +2552,9 @@
	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
	if (!wait_loop)
		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
+#ifdef DEV_NETMAP
+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
+#endif /* DEV_NETMAP */
 }

 static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
@@ -2833,6 +2869,10 @@
	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);

	ixgbe_rx_desc_queue_enable(adapter, ring);
+#ifdef DEV_NETMAP
+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
+		return;
+#endif /* DEV_NETMAP */
	ixgbe_alloc_rx_buffers(adapter, ring, IXGBE_DESC_UNUSED(ring));
 }

@@ -5253,6 +5293,9 @@
		goto err_up;

	netif_tx_start_all_queues(netdev);
+#ifdef DEV_NETMAP
+	ixgbe_netmap_attach(adapter);
+#endif /* DEV_NETMAP */

	return 0;
